import ctypes
from math import sqrt
import socket
import struct


def ip2int(addr):
	return struct.unpack("!I", socket.inet_aton(addr))[0]


def int2ip(addr):
	return socket.inet_ntoa(struct.pack("!I", addr))


class blackhold:
	s_box = [
		0x91, 0x58, 0xb3, 0x31, 0x6c, 0x33, 0xda, 0x88,
		0x57, 0xdd, 0x8c, 0xf2, 0x29, 0x5a, 0x08, 0x9f,
		0x49, 0x34, 0xce, 0x99, 0x9e, 0xbf, 0x0f, 0x81,
		0xd4, 0x2f, 0x92, 0x3f, 0x95, 0xf5, 0x23, 0x00,
		0x0d, 0x3e, 0xa8, 0x90, 0x98, 0xdd, 0x20, 0x00,
		0x03, 0x69, 0x0a, 0xca, 0xba, 0x12, 0x08, 0x41,
		0x6e, 0xb9, 0x86, 0xe4, 0x50, 0xf0, 0x84, 0xe2,
		0xb3, 0xb3, 0xc8, 0xb5, 0xb2, 0x2d, 0x18, 0x70,
		
		0x0a, 0xd7, 0x92, 0x90, 0x9e, 0x1e, 0x0c, 0x1f,
		0x08, 0xe8, 0x06, 0xfd, 0x85, 0x2f, 0xaa, 0x5d,
		0xcf, 0xf9, 0xe3, 0x55, 0xb9, 0xfe, 0xa6, 0x7f,
		0x44, 0x3b, 0x4a, 0x4f, 0xc9, 0x2f, 0xd2, 0xd3,
		0x8e, 0xdc, 0xae, 0xba, 0x4f, 0x02, 0xb4, 0x76,
		0xba, 0x64, 0x2d, 0x07, 0x9e, 0x08, 0xec, 0xbd,
		0x52, 0x29, 0x07, 0xbb, 0x9f, 0xb5, 0x58, 0x6f,
		0x07, 0x55, 0xb0, 0x34, 0x74, 0x9f, 0x05, 0xb2,
		
		0xdf, 0xa9, 0xc6, 0x2a, 0xa3, 0x5d, 0xff, 0x10,
		0x40, 0xb3, 0xb7, 0xb4, 0x63, 0x6e, 0xf4, 0x3e,
		0xee, 0xf6, 0x49, 0x52, 0xe3, 0x11, 0xb3, 0xf1,
		0xfb, 0x60, 0x48, 0xa1, 0xa4, 0x19, 0x7a, 0x2e,
		0x90, 0x28, 0x90, 0x8d, 0x5e, 0x8c, 0x8c, 0xc4,
		0xf2, 0x4a, 0xf6, 0xb2, 0x19, 0x83, 0xea, 0xed,
		0x6d, 0xba, 0xfe, 0xd8, 0xb6, 0xa3, 0x5a, 0xb4,
		0x48, 0xfa, 0xbe, 0x5c, 0x69, 0xac, 0x3c, 0x8f,
		
		0x63, 0xaf, 0xa4, 0x42, 0x25, 0x50, 0xab, 0x65,
		0x80, 0x65, 0xb9, 0xfb, 0xc7, 0xf2, 0x2d, 0x5c,
		0xe3, 0x4c, 0xa4, 0xa6, 0x8e, 0x07, 0x9c, 0xeb,
		0x41, 0x93, 0x65, 0x44, 0x4a, 0x86, 0xc1, 0xf6,
		0x2c, 0x97, 0xfd, 0xf4, 0x6c, 0xdc, 0xe1, 0xe0,
		0x28, 0xd9, 0x89, 0x7b, 0x09, 0xe2, 0xa0, 0x38,
		0x74, 0x4a, 0xa6, 0x5e, 0xd2, 0xe2, 0x4d, 0xf3,
		0xf4, 0xc6, 0xbc, 0xa2, 0x51, 0x58, 0xe8, 0xae,
	]
	
	def __init__(self, range: int, seed: int, rounds: int):
		"""
		获取某一范围内的随机数，这个范围从0开始。注意，这个并不能保证全部取完所有范围内的数字，或多或少有重复，漏的现象。
		但是这个时间复杂度比较好，空间复杂度为o(1)
		:param range: 范围
		:param seed: 种子
		:param rounds: aes的s-box的轮数，一般设置到14比较好
		"""
		self.range = range
		foo = sqrt(range * 1.0)
		if range == 0:
			self.a = 0
			self.b = 0
		else:
			self.a = int(foo - 2)
			self.b = int(foo + 3)
		while self.a * self.b <= self.range:
			self.b += 1
		self.rounds = rounds
		self.seed = seed
		self.range = range
	
	def __read__(self, r: int, R: int, seed: int):
		R ^= (seed << r) ^ (seed >> (64 - r))
		GETBYTE = lambda R, n: ((R >> (n * 8)) ^ self.seed ^ r) & 0xFF
		
		r0 = self.s_box[GETBYTE(R, 0)] << 0 | self.s_box[GETBYTE(R, 1)] << 8
		r1 = (self.s_box[GETBYTE(R, 2)] << 16 | self.s_box[GETBYTE(R, 3)] << 24) & 0x0ffffFFFF
		r2 = self.s_box[GETBYTE(R, 4)] << 0 | self.s_box[GETBYTE(R, 5)] << 8
		r3 = (self.s_box[GETBYTE(R, 6)] << 16 | self.s_box[GETBYTE(R, 7)] << 24) & 0x0ffffFFFF
		
		R = ctypes.c_uint64(r0 ^ r1 ^ r2 << 23 ^ r3 << 33)
		
		return R.value
	
	def __encrypt__(self, m):
		
		L = int(m % self.a)
		R = int(m / self.a)
		
		j = 1
		while j <= self.rounds:
			if j & 1:
				tmp = int((L + self.__read__(j, R, self.seed)) % self.a)
			else:
				tmp = int((L + self.__read__(j, R, self.seed)) % self.b)
			
			L = R
			R = tmp
			j += 1
		
		if self.rounds & 1:
			return self.a * L + R
		else:
			return self.a * R + L
	
	def shuffle(self, m):
		c = self.__encrypt__(m)
		while c >= self.range:
			c = self.__encrypt__(c)
		return c


if __name__ == '__main__':
	ran = 255
	base = ip2int("192.168.3.100")
	print(base)
	seed = 874972984789729
	blackhold = blackhold(ran, seed, 20)
	m = 0
	l = []
	for i in range(ran):
		m = blackhold.shuffle(m)
		l.append(m)
		print(m)
		# print(int2ip(base + m ))

